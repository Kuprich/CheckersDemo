
<div class="board">
    @for (int i = 0; i < 8; i++)
    {
        int row = i;
        <div class="board__row">
            @for (var j = 0; j < 8; j++)
            {
                int col = j;

                var checker = _checkers.FirstOrDefault(x => x.Row == row && x.Column == col);

                bool canMoveHere = _cellsPossible.Contains((row, col));

                <div @onclick="() => MoveChecker(row, col)" class="board__col @(canMoveHere ? "board__col-active": "")">
                    @{
                        if (checker != null)
                        {
                            <div @onclick="() => CheckerClicked(checker)" class="checker checker-@(checker.IsWhite ? "white" : "black" ) @(_activeChecker == checker ? "checker-active": "") @(checker.Direction == CheckerDirection.Both ? "checker-king" : "")"></div>
                        }
                    }
                </div>
            }
        </div>
    }
</div>


@code {
    List<Checker> _checkers = new();

    Checker? _activeChecker = null;
    Checker? _beingAttackedChecker = null;
    bool _whiteTurn = true;

    List<(int row, int col)> _cellsPossible = new();

    protected override Task OnInitializedAsync()
    {
        for (int row = 0; row < 3; row++)
        {
            for (int col = (row + 1) % 2; col < 8; col += 2)
            {
                _checkers.Add(new Checker(row, col, CheckerDirection.Down, isWhite: false));
            }
        }

        for (int row = 5; row < 8; row++)
        {
            for (int col = (row + 1) % 2; col < 8; col += 2)
            {
                _checkers.Add(new Checker(row, col, CheckerDirection.Up, isWhite: true));
            }
        }

        return base.OnInitializedAsync();
    }

    private void CheckerClicked(Checker checker)
    {
        if (_whiteTurn && !checker.IsWhite ||
            !_whiteTurn && checker.IsWhite) return;


        EvaluateCheckerSpots(checker);

        if (!_cellsPossible.Any())
        {
            _activeChecker = null;
            return;
        }

        _activeChecker = checker;

    }

    private void EvaluateCheckerSpots(Checker checker)
    {
        _cellsPossible.Clear();

        EvaluateSpotForJump(checker);

        if (!_cellsPossible.Any())
        {
            EvaluateSpotForMove(checker);
        }

    }

    private void EvaluateSpotForJump(Checker checker)
    {
        _beingAttackedChecker = null;

        List<int> rowsPossibleForJump = new();
        List<int> colsPossibleForJump = new();

        rowsPossibleForJump.AddBoardValues(new[] { checker.Row + 2, checker.Row - 2 });
        colsPossibleForJump.AddBoardValues(new[] { checker.Column + 2, checker.Column - 2 });

        foreach (int row in rowsPossibleForJump)
            foreach (int col in colsPossibleForJump)
            {
                if (Math.Abs(checker.Column - col) != Math.Abs(checker.Row - row)) continue;

                if (_checkers.FirstOrDefault(x => x.Row == row && x.Column == col) != null) continue;

                var possibleAttackedChecker = _checkers.FirstOrDefault(x => x.Row == (checker.Row + row) / 2 && x.Column == (checker.Column + col) / 2);
                if (possibleAttackedChecker != null && checker.IsWhite != possibleAttackedChecker.IsWhite)
                {
                    _beingAttackedChecker = possibleAttackedChecker;
                    _cellsPossible.Add((row, col));
                }

            }
    }

    private void EvaluateSpotForMove(Checker checker)
    {

        List<int> rowsPossibleForMove = new();
        List<int> colsPossibleForMove = new();

        if (checker.Direction == CheckerDirection.Both)
        {
            rowsPossibleForMove.AddBoardValues(new[] { checker.Row + 1, checker.Row - 1 });
        }
        else
        {
            rowsPossibleForMove.AddBoardValue(checker.Row + (1 * (checker.Direction == CheckerDirection.Down ? 1 : -1)));
        }

        colsPossibleForMove.AddBoardValues(new[] { checker.Column + 1, checker.Column - 1 });

        foreach (int row in rowsPossibleForMove)
            foreach (int col in colsPossibleForMove)
            {
                if (Math.Abs(checker.Column - col) != Math.Abs(checker.Row - row)) continue;

                if (_checkers.FirstOrDefault(x => x.Row == row && x.Column == col) != null) continue;

                _cellsPossible.Add((row, col));

            }
    }

    private void MoveChecker(int row, int col)
    {

        bool canMoveHere = _cellsPossible.Contains((row, col));
        if (!canMoveHere) return;

        if (_activeChecker != null)
        {
            _activeChecker.Column = col;
            _activeChecker.Row = row;

            if (_beingAttackedChecker != null)
            {
                _checkers.Remove(_beingAttackedChecker);

            }

            if (_activeChecker.Row == 0 && _activeChecker.IsWhite ||
                _activeChecker.Row == 7 && !_activeChecker.IsWhite)
            {
                _activeChecker.Direction = CheckerDirection.Both;
            }
        }

        _activeChecker = null;
        _whiteTurn = !_whiteTurn;
        _cellsPossible.Clear();

    }
}
